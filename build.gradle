/*
 * Copyright 2016 SRI International
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// $Id: build.gradle 7401 2016-03-25 20:18:20Z Chris Jones (E24486) $

plugins {
    id "org.sonarqube" version "1.2"
}

description = "Root of the tasklearning tree"

// These must be applied at the top level if they're going to be used
// in any sub-projects:
apply plugin: 'eclipse'
apply plugin: 'idea'

def javaHome = System.properties['java.home']

// Where do we get jar files from?
allprojects {
    repositories {
        mavenCentral()
        flatDir name: 'sri', dirs: "$rootDir.path/libs/sri"
        flatDir name: 'gradle', dirs: "$rootDir.path/gradle/lib"
        // TODO Use this instead of the previous bunch.
        // ivy {
        //     ivyPattern "$rootDir/libs/[module]-ivy-[revision].xml"
        //     artifactPattern "rootDir/libs/[module](-[revision]).[ext]"
        // }
    }
}
// Additional magic to add the JavaFX dependency possible locations.
try {
    Class.forName("javafx.stage.Stage")
} catch(Exception e) {
    allprojects {
        repositories {
            flatDir name: 'javafx', dirs: ["$javaHome/jre/lib",
                                           "$javaHome/lib",
                                           "$javaHome/../lib"]
        }
    }
}

// Assign release, build, and revision. Release is the major version
// number of the software, set by hand. Build is assigned by
// Jenkins. Revision is read from version control.
project.ext.release = '1'
project.ext.build = System.env.BUILD_NUMBER
if (build == null) {
    project.ext.build = 'dev'
}
def stdout = new ByteArrayOutputStream()
import org.gradle.process.internal.ExecException
try {
    exec {
        executable = 'svnversion'
        args = [ '.' ]
        standardOutput = stdout
        ignoreExitValue = true
    }
} catch(ExecException e) {
    println(e)
}
project.ext.revision = stdout.toString().trim().replace(':', '-')
revision = revision.replaceAll("[+]", "")
if (revision == "") {
    println("WARNING! Unable to determine revision number")
    revision = 'unknown'
}
// Set the branch of the repository.
stdout.reset()
try {
    exec {
        executable = "svn"
        args = [ "info", "." ]
        standardOutput = stdout
        ignoreExitValue = true
    }
} catch(ExecException e) {
    println(e)
}
project.ext.branch = ""
for (String line : stdout.toString().split("\n")) {
    if (line.startsWith("URL: ")) {
        project.ext.branch = line.substring(5).trim().replaceFirst("^.*/", "")
    }
}
if (branch == "") {
    println("WARNING! Unable to determine branch")
    branch = "unknown"
}
project.version = "$release.$revision"

allprojects {
    defaultTasks = ["jar"]
}

// Configure Sonar.
sonarqube {
    properties {
        property "sonar.host.url", "https://sonar.cse.sri.com/"
        property "sonar.analysis.mode", "preview" // publish, preview, issues
        property "sonar.branch", "$branch"
        property "sonar.login", "sonar_tasklearning"
        property "sonar.password", "Bx!Xw88^*tkgWf^"
        property "sonar.links.ci", "http://tasklearning-jenkins.cse.sri.com:8080/"
        property "sonar.links.issue", "https://jira.esg.sri.com/browse/TLEARN"
        property "sonar.links.scm", "https://scm.sri.com/scm/svn/LearningByDemonstration/tasklearning"
        property "sonar.svn.username", "lbdbuild"
        property "sonar.svn.password.secured", '&UsH5p^wd%9ZUg2'
//        property "sonar.scm.disabled", true
   }
}

// This task is called by the autobuild system, e.g., Jenkins.
task autobuild

task cleanDist(type: Delete) {
    delete "$rootDir/dist"
}
task clean
clean.dependsOn(cleanDist)
// Also make a "flat" directory containing all the jars together, and
// rename them to not contain version info.
task uploadArchives {
    doLast {
        def flatDir = file("$rootDir/dist/flat")
        def simpleDir = file("$rootDir/dist/simple")
        flatDir.mkdirs()
        ant.copy(todir: flatDir, flatten: 'true') {
            fileset(dir: "$rootDir/dist/maven") {
                include(name: "**/*.jar")
            }
        }
        simpleDir.mkdirs()
        copy {
            from flatDir
            into simpleDir
            rename { str ->
                str.replaceAll('-[0-9].*\\.jar', '.jar')
            }
        }
    }
}
// And add products of custom tasks to the artifacts list:
// artifacts {
//     archives makeDocZip
// }

// Simplify the task of importing jar files from Lumen and LAPDOG. To
// make this target work, first copy lumen.jar into the appropriate
// lib directory. This will remove the old lumen-1234.jar, then rename
// the new one to lumen-1235.jar and svn add it.
task importJars {
    def libDir = file("$rootDir/libs/sri")
    doLast {
        FileTree jars = fileTree(libDir)
        jars.include("*.jar")
        jars.exclude("TerraSightWebService*.jar")
        jars.exclude("remotexml-*.jar")
        jars.each { File file ->
            println("Working on $file")

            // Read the version from the jar's manifest.
            def jarFile = new java.util.jar.JarFile(file)
            def mf = jarFile.getManifest()
            def attrs = mf.getMainAttributes()
            def jarVers = attrs.getValue("Implementation-Version").trim()
            jarFile.close()
            println("...version: ${jarVers}")

            // Sanity check the version. Don't allow "53-54" or
            // "53:54" or "53M".
            assert(jarVers.length() > 0)
            assert(!jarVers.contains("-"))
            assert(!jarVers.contains(":"))
            assert(!jarVers.contains("M"))

            if(file.name.contains(jarVers)) {
                println("${file} already has ${jarVers} in its name; skipping")
            } else {
                def basename = file.name.replace(".jar", "")

                // Remove the old one.
                def FileTree oldJars = fileTree(libDir)
                oldJars.findAll { File oldJar ->
                    oldJar.name.matches("${basename}-[0-9.]+\\.jar")
                }.each { File oldJar ->
                    println("Removing " + relativePath(oldJar.path))
                    delete(oldJar)
                }

                // Rename the new one and svn add it.
                def newname = basename + "-" + jarVers + ".jar"
                def newfile = new File(libDir, newname)
                file.renameTo(newfile)
            }
        }

        println("Don't forget to add the new files to version control and delete the old ones!")
    }
}

// Gradle script to flag unused jar files. If the CPOF-related source
// is present, include its source tree in our search.
apply from: "$rootDir/gradle/scripts/unusedJars.gradle"
ext.shellDir = file("$rootDir/../shell")
if(shellDir.isDirectory()) {
    unusedJars.baseDir = "$rootDir/.."
}
